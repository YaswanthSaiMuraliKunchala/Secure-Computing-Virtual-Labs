<%- include('../partials/header') %>

<div class="experiment-container" data-experiment-type="data-encryption-standard">
  <!-- Left Column - Theory and Visualization -->
  <div class="experiment-left">
    <!-- Experiment Title -->
    <div class="card mb-4">
      <div class="card-header bg-primary text-white">
        <h3 class="mb-0">Data Encryption Standard (DES)</h3>
      </div>
    </div>
    
    <!-- Aim Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-bullseye section-icon"></i> Aim
        </h5>
      </div>
      <div class="card-body">
        <p>To implement a symmetric-key block cipher algorithm known as Data Encryption Standard (DES).</p>
      </div>
    </div>
    
    <!-- Algorithm Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-code-branch section-icon"></i> Algorithm
        </h5>
      </div>
      <div class="card-body">
        <ol>
          <li>Hexadecimal to Binary Conversion (hex2bin):
            <ul>
              <li>Initialize a dictionary that maps each hexadecimal digit to its 4-bit binary equivalent.</li>
              <li>Initialize an empty string for the binary result.</li>
              <li>For each character in the input hexadecimal string:
                <ul>
                  <li>Append the corresponding binary string from the dictionary to the result.</li>
                </ul>
              </li>
              <li>Return the binary result.</li>
            </ul>
          </li>
          <li>Binary to Hexadecimal Conversion (bin2hex):
            <ul>
              <li>Initialize a dictionary that maps each 4-bit binary string to its hexadecimal equivalent.</li>
              <li>Initialize an empty string for the hexadecimal result.</li>
              <li>For each group of 4 bits in the input binary string:
                <ul>
                  <li>Append the corresponding hexadecimal character from the dictionary to the result.</li>
                </ul>
              </li>
              <li>Return the hexadecimal result.</li>
            </ul>
          </li>
          <li>Binary to Decimal Conversion (bin2dec):
            <ul>
              <li>Initialize the decimal result to 0.</li>
              <li>For each bit in the input binary string, from least significant to most significant:
                <ul>
                  <li>Multiply the bit by 2<sup>i</sup> (where i is the bit's position) and add to the decimal result.</li>
                </ul>
              </li>
              <li>Return the decimal result.</li>
            </ul>
          </li>
          <li>Decimal to Binary Conversion (dec2bin):
            <ul>
              <li>Convert the decimal number to its binary representation using Python's bin function and remove the "0b" prefix.</li>
              <li>If the length of the binary result is not a multiple of 4, pad with leading zeros to make it a multiple of 4.</li>
              <li>Return the padded binary result.</li>
            </ul>
          </li>
          <li>Permute Function (permute):
            <ul>
              <li>Initialize an empty string for the permutation result.</li>
              <li>For each position in the permutation array:
                <ul>
                  <li>Append the bit from the input string at the given position to the result.</li>
                </ul>
              </li>
              <li>Return the permutation result.</li>
            </ul>
          </li>
          <li>Left Shift Function (shift_left):
            <ul>
              <li>For the specified number of shifts:
                <ul>
                  <li>Perform a left circular shift on the input string.</li>
                </ul>
              </li>
              <li>Return the shifted string.</li>
            </ul>
          </li>
          <li>XOR Function (xor):
            <ul>
              <li>Initialize an empty string for the XOR result.</li>
              <li>For each bit in the input strings:
                <ul>
                  <li>Append the result of the XOR operation on the corresponding bits to the result.</li>
                </ul>
              </li>
              <li>Return the XOR result.</li>
            </ul>
          </li>
          <li>Encryption Function (encrypt):
            <ul>
              <li>Convert the plaintext from hexadecimal to binary using hex2bin.</li>
              <li>Perform an initial permutation using the initial_perm table.</li>
              <li>Split the permuted text into left and right halves.</li>
              <li>For each of the 16 rounds:
                <ul>
                  <li>Expand the right half from 32 to 48 bits using the exp_d table.</li>
                  <li>XOR the expanded right half with the round key.</li>
                  <li>Substitute the result using the S-boxes.</li>
                  <li>Perform a permutation using the per table.</li>
                  <li>XOR the result with the left half.</li>
                  <li>Swap the left and right halves, except in the final round.</li>
                </ul>
              </li>
              <li>Combine the final left and right halves.</li>
              <li>Perform a final permutation using the final_perm table.</li>
              <li>Return the result as binary.</li>
            </ul>
          </li>
          <li>Key Generation:
            <ul>
              <li>Convert the key from hexadecimal to binary using hex2bin.</li>
              <li>Perform a parity bit drop using the keyp table to get a 56-bit key.</li>
              <li>Split the key into left and right halves.</li>
              <li>For each of the 16 rounds:
                <ul>
                  <li>Perform left shifts on both halves according to the shift_table.</li>
                  <li>Combine the left and right halves.</li>
                  <li>Compress the key from 56 to 48 bits using the key_comp table.</li>
                  <li>Append the round key in both binary and hexadecimal form to the round key lists.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Main Process:
            <ul>
              <li>Define the plaintext and key in hexadecimal format.</li>
              <li>Generate the round keys.</li>
              <li>Perform encryption using the generated round keys.</li>
              <li>Reverse the round keys for decryption.</li>
              <li>Perform decryption using the reversed round keys.</li>
            </ul>
          </li>
        </ol>
      </div>
    </div>
    
    <!-- Sample Input/Output Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-exchange-alt section-icon"></i> Sample Input/Output
        </h5>
      </div>
      <div class="card-body">
<div class="row">
          <div class="col-md-6">
            <h6><i class="fas fa-sign-in-alt me-2"></i>Sample Input:</h6>
            <pre class="bg-light p-3 rounded">Plaintext (hex): "123456ABCD132536"
Key (hex): "AABB09182736CCDD"</pre>
          </div>
          <div class="col-md-6">
            <h6><i class="fas fa-sign-out-alt me-2"></i>Sample Output:</h6>
            <pre class="bg-light p-3 rounded">Encrypted (hex): "C0B7A8D05F3A829C"
Decrypted (hex): "123456ABCD132536"</pre>
          </div>
        </div>
  </div>
    </div>
    
    <!-- Visualization Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-chart-bar section-icon"></i> Visualization
        </h5>
      </div>
      <div class="card-body">
        <div class="mb-3">
          <label for="input-text" class="form-label">Plaintext (Hexadecimal):</label>
          <input type="text" class="form-control" id="input-text" value="123456ABCD132536" pattern="[0-9A-Fa-f]+" maxlength="16">
          <small class="form-text text-muted">Enter 16 hexadecimal characters (64 bits)</small>
        </div>
        
        <div class="mb-3">
          <label for="key-value" class="form-label">Key (Hexadecimal):</label>
          <input type="text" class="form-control" id="key-value" value="AABB09182736CCDD" pattern="[0-9A-Fa-f]+" maxlength="16">
          <small class="form-text text-muted">Enter 16 hexadecimal characters (64 bits)</small>
        </div>
        
        <button class="btn btn-primary" id="visualize-btn">
          <i class="fas fa-play me-2"></i>Visualize
        </button>
        
        <div id="visualization-section" class="mt-4 d-none">
          <ul class="nav nav-tabs" id="desVisualizationTabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="key-generation-tab" data-bs-toggle="tab" data-bs-target="#key-generation" type="button" role="tab" aria-controls="key-generation" aria-selected="true">Key Generation</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="encryption-tab" data-bs-toggle="tab" data-bs-target="#encryption" type="button" role="tab" aria-controls="encryption" aria-selected="false">Encryption</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="decryption-tab" data-bs-toggle="tab" data-bs-target="#decryption" type="button" role="tab" aria-controls="decryption" aria-selected="false">Decryption</button>
            </li>
          </ul>
          
          <div class="tab-content mt-3" id="desVisualizationTabContent">
            <div class="tab-pane fade show active" id="key-generation" role="tabpanel" aria-labelledby="key-generation-tab">
              <h6 class="mb-3">Key Generation Process:</h6>
              <div class="table-responsive">
                <table class="table table-bordered table-striped" id="key-generation-table">
                  <thead>
                    <tr>
                      <th>Round</th>
                      <th>Left Shift</th>
                      <th>Combined Key</th>
                      <th>Round Key (Binary)</th>
                      <th>Round Key (Hex)</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Will be populated by JavaScript -->
                  </tbody>
                </table>
              </div>
            </div>
            
            <div class="tab-pane fade" id="encryption" role="tabpanel" aria-labelledby="encryption-tab">
              <h6 class="mb-3">Encryption Process:</h6>
              <div class="table-responsive">
                <table class="table table-bordered table-striped" id="encryption-table">
                  <thead>
                    <tr>
                      <th>Round</th>
                      <th>Left Half</th>
                      <th>Right Half</th>
                      <th>Round Key</th>
                      <th>After F-function</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Will be populated by JavaScript -->
                  </tbody>
                </table>
              </div>
            </div>
            
            <div class="tab-pane fade" id="decryption" role="tabpanel" aria-labelledby="decryption-tab">
              <h6 class="mb-3">Decryption Process:</h6>
              <div class="table-responsive">
                <table class="table table-bordered table-striped" id="decryption-table">
                  <thead>
                    <tr>
                      <th>Round</th>
                      <th>Left Half</th>
                      <th>Right Half</th>
                      <th>Round Key</th>
                      <th>After F-function</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Will be populated by JavaScript -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          
          <div class="mt-4">
            <div class="card">
              <div class="card-header bg-success text-white">
                <h6 class="mb-0">Final Results</h6>
              </div>
              <div class="card-body">
                <div class="row">
                  <div class="col-md-6">
                    <h6>Plaintext:</h6>
                    <div class="bg-light p-3 rounded mb-3" id="plaintext-display"></div>
                    
                    <h6>Encrypted (Hex):</h6>
                    <div class="bg-light p-3 rounded" id="encrypted-display"></div>
                  </div>
                  <div class="col-md-6">
                    <h6>Key:</h6>
                    <div class="bg-light p-3 rounded mb-3" id="key-display"></div>
                    
                    <h6>Decrypted (Hex):</h6>
                    <div class="bg-light p-3 rounded" id="decrypted-display"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      </div>
    </div>
    
  <!-- Right Column - Code Editor and Output -->
  <div class="experiment-right">
    <!-- Code Editor Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-keyboard section-icon"></i> Code
        </h5>
      </div>
      <div class="card-body">
        <!-- Language Selection -->
          <div class="mb-3">
          <label for="language-select" class="form-label">Select Language:</label>
          <select class="form-select" id="language-select">
            <option value="javascript">JavaScript</option>
            <option value="python">Python</option>
            <option value="java">Java</option>
            <option value="c">C</option>
            <option value="cpp">C++</option>
          </select>
        </div>
        
        <div class="code-editor-container">
          <div id="code-editor-wrapper">
            <!-- Code Mirror editor will be initialized here -->
            <textarea id="code-editor" class="form-control" rows="15">// Data Encryption Standard Implementation

// Initial Permutation table
const IP = [
    58, 50, 42, 34, 26, 18, 10, 2,
    60, 52, 44, 36, 28, 20, 12, 4,
    62, 54, 46, 38, 30, 22, 14, 6,
    64, 56, 48, 40, 32, 24, 16, 8,
    57, 49, 41, 33, 25, 17, 9, 1,
    59, 51, 43, 35, 27, 19, 11, 3,
    61, 53, 45, 37, 29, 21, 13, 5,
    63, 55, 47, 39, 31, 23, 15, 7
];

// Permutation Choice 1 table
const PC1 = [
    57, 49, 41, 33, 25, 17, 9,
    1, 58, 50, 42, 34, 26, 18,
    10, 2, 59, 51, 43, 35, 27,
    19, 11, 3, 60, 52, 44, 36,
    63, 55, 47, 39, 31, 23, 15,
    7, 62, 54, 46, 38, 30, 22,
    14, 6, 61, 53, 45, 37, 29,
    21, 13, 5, 28, 20, 12, 4
];

// Helper functions
function stringToHex(str) {
    let hex = '';
    for (let i = 0; i < str.length; i++) {
        hex += str.charCodeAt(i).toString(16).padStart(2, '0');
    }
    return hex.toUpperCase();
}

function hexToString(hex) {
    let str = '';
    for (let i = 0; i < hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return str;
}

function generateSubKeys(key) {
    // Implementation of key generation
  // Your code here
}

function encrypt(text, key) {
    // Convert input to binary
    const binaryText = stringToHex(text)
        .split('')
        .map(c => parseInt(c, 16).toString(2).padStart(4, '0'))
        .join('');
    
    // Apply initial permutation
    let permuted = '';
    for (let i = 0; i < IP.length; i++) {
        permuted += binaryText[IP[i] - 1];
    }
    
    // Split into left and right halves
    let left = permuted.slice(0, 32);
    let right = permuted.slice(32);
    
    // Generate subkeys
    const subkeys = generateSubKeys(key);
    
    // 16 rounds of Feistel network
    for (let round = 0; round < 16; round++) {
        const oldRight = right;
        right = xor(left, feistel(right, subkeys[round]));
        left = oldRight;
    }
    
    // Final permutation
    const combined = right + left; // Note: Swap left and right
    let result = '';
    for (let i = 0; i < FP.length; i++) {
        result += combined[FP[i] - 1];
    }
    
    // Convert back to hex
    return binaryToHex(result);
}

function decrypt(ciphertext, key) {
    // Implementation of decryption
  // Your code here
}

// Test the implementation
const plaintext = "Hello123";
const key = "ABCD1234";

const encrypted = encrypt(plaintext, key);
console.log("Encrypted (hex):", encrypted);

const decrypted = decrypt(encrypted, key);
console.log("Decrypted:", decrypted);</textarea>
          </div>
        </div>
        
        <div class="mt-3 d-flex justify-content-between">
          <button class="btn btn-secondary" id="clear-code-btn">
            <i class="fas fa-eraser me-2"></i>Clear Code
            </button>
          <button class="btn btn-primary" id="run-code-btn">
            <i class="fas fa-play me-2"></i>Run Code
            </button>
          </div>
      </div>
    </div>
    
    <!-- Output Section -->
    <div class="card mb-4">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="fas fa-terminal section-icon"></i> Output
        </h5>
      </div>
      <div class="card-body">
        <div class="code-output bg-dark text-light p-3 rounded" id="code-output">
          <div class="text-muted">Run your code to see the output here...</div>
        </div>
        
        <div class="mt-3 d-flex justify-content-end">
          <button class="btn btn-success" id="submit-code-btn">
            <i class="fas fa-paper-plane me-2"></i>Submit
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- CodeMirror CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/anyword-hint.min.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Set experiment type on body
    document.body.setAttribute('data-experiment-type', 'data-encryption-standard');
    
    // Initialize CodeMirror
    const codeEditorTextarea = document.getElementById('code-editor');
    const codeEditor = CodeMirror.fromTextArea(codeEditorTextarea, {
      lineNumbers: true,
      mode: 'javascript',
      theme: 'dracula',
      indentUnit: 2,
      smartIndent: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      matchBrackets: true,
      autoCloseBrackets: true,
      extraKeys: {
        "Ctrl-Space": "autocomplete",
        "Tab": function(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.replaceSelection("  ", "end");
          }
        }
      }
    });
    
    // DES Tables
    const initialPermutation = [
      58, 50, 42, 34, 26, 18, 10, 2,
      60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6,
      64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17, 9, 1,
      59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5,
      63, 55, 47, 39, 31, 23, 15, 7
    ];
    
    const finalPermutation = [
      40, 8, 48, 16, 56, 24, 64, 32,
      39, 7, 47, 15, 55, 23, 63, 31,
      38, 6, 46, 14, 54, 22, 62, 30,
      37, 5, 45, 13, 53, 21, 61, 29,
      36, 4, 44, 12, 52, 20, 60, 28,
      35, 3, 43, 11, 51, 19, 59, 27,
      34, 2, 42, 10, 50, 18, 58, 26,
      33, 1, 41, 9, 49, 17, 57, 25
    ];
    
    const keyPermutation = [
      57, 49, 41, 33, 25, 17, 9,
      1, 58, 50, 42, 34, 26, 18,
      10, 2, 59, 51, 43, 35, 27,
      19, 11, 3, 60, 52, 44, 36,
      63, 55, 47, 39, 31, 23, 15,
      7, 62, 54, 46, 38, 30, 22,
      14, 6, 61, 53, 45, 37, 29,
      21, 13, 5, 28, 20, 12, 4
    ];
    
    const keyCompression = [
      14, 17, 11, 24, 1, 5, 3, 28,
      15, 6, 21, 10, 23, 19, 12, 4,
      26, 8, 16, 7, 27, 20, 13, 2,
      41, 52, 31, 37, 47, 55, 30, 40,
      51, 45, 33, 48, 44, 49, 39, 56,
      34, 53, 46, 42, 50, 36, 29, 32
    ];
    
    const expansionTable = [
      32, 1, 2, 3, 4, 5,
      4, 5, 6, 7, 8, 9,
      8, 9, 10, 11, 12, 13,
      12, 13, 14, 15, 16, 17,
      16, 17, 18, 19, 20, 21,
      20, 21, 22, 23, 24, 25,
      24, 25, 26, 27, 28, 29,
      28, 29, 30, 31, 32, 1
    ];
    
    const sBoxes = [
      // S1
      [
        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
        [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
        [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
        [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
      ],
      // S2-S8 would be defined similarly
    ];
    
    const pBox = [
      16, 7, 20, 21, 29, 12, 28, 17,
      1, 15, 23, 26, 5, 18, 31, 10,
      2, 8, 24, 14, 32, 27, 3, 9,
      19, 13, 30, 6, 22, 11, 4, 25
    ];
    
    const shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    
    // Helper functions
    function hexToBin(hex) {
      const hexMap = {
        '0': '0000', '1': '0001', '2': '0010', '3': '0011',
        '4': '0100', '5': '0101', '6': '0110', '7': '0111',
        '8': '1000', '9': '1001', 'A': '1010', 'B': '1011',
        'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111',
        'a': '1010', 'b': '1011', 'c': '1100', 'd': '1101',
        'e': '1110', 'f': '1111'
      };
      
      let binary = '';
      for (let i = 0; i < hex.length; i++) {
        binary += hexMap[hex[i]] || '';
      }
      return binary;
    }
    
    function binToHex(bin) {
      const binMap = {
        '0000': '0', '0001': '1', '0010': '2', '0011': '3',
        '0100': '4', '0101': '5', '0110': '6', '0111': '7',
        '1000': '8', '1001': '9', '1010': 'A', '1011': 'B',
        '1100': 'C', '1101': 'D', '1110': 'E', '1111': 'F'
      };
      
      let hex = '';
      for (let i = 0; i < bin.length; i += 4) {
        const chunk = bin.substr(i, 4);
        hex += binMap[chunk] || '';
      }
      return hex;
    }
    
    function permute(input, table) {
      let result = '';
      for (let i = 0; i < table.length; i++) {
        result += input[table[i] - 1];
      }
      return result;
    }
    
    function leftShift(key, shifts) {
      return key.substring(shifts) + key.substring(0, shifts);
    }
    
    function xor(a, b) {
      let result = '';
      for (let i = 0; i < a.length; i++) {
        result += (a[i] === b[i]) ? '0' : '1';
      }
      return result;
    }
    
    // DES Key Generation
    function generateKeys(key) {
      // Convert hex key to binary
      const binaryKey = hexToBin(key);
      
      // Apply key permutation
      const permutedKey = permute(binaryKey, keyPermutation);
      
      // Split into left and right halves
      let left = permutedKey.substring(0, 28);
      let right = permutedKey.substring(28);
      
      const roundKeys = [];
      const keyGenerationSteps = [];
      
      for (let i = 0; i < 16; i++) {
        // Perform left shifts
        left = leftShift(left, shiftTable[i]);
        right = leftShift(right, shiftTable[i]);
        
        // Combine left and right halves
        const combinedKey = left + right;
        
        // Apply key compression
        const roundKey = permute(combinedKey, keyCompression);
        roundKeys.push(roundKey);
        
        // Store steps for visualization
        keyGenerationSteps.push({
          round: i + 1,
          leftShift: shiftTable[i],
          combinedKey: combinedKey,
          roundKey: roundKey,
          roundKeyHex: binToHex(roundKey)
        });
      }
      
      return { roundKeys, keyGenerationSteps };
    }
    
    // DES Encryption
    function encrypt(plaintext, roundKeys) {
      // Convert hex plaintext to binary
      const binaryPlaintext = hexToBin(plaintext);
      
      // Apply initial permutation
      const permutedPlaintext = permute(binaryPlaintext, initialPermutation);
      
      // Split into left and right halves
      let left = permutedPlaintext.substring(0, 32);
      let right = permutedPlaintext.substring(32);
      
      const encryptionSteps = [];
      
      for (let i = 0; i < 16; i++) {
        // Expand right half
        const expandedRight = permute(right, expansionTable);
        
        // XOR with round key
        const xorResult = xor(expandedRight, roundKeys[i]);
        
        // Apply S-boxes (simplified for visualization)
        let sBoxOutput = '';
        for (let j = 0; j < 8; j++) {
          const chunk = xorResult.substring(j * 6, (j + 1) * 6);
          const row = parseInt(chunk[0] + chunk[5], 2);
          const col = parseInt(chunk.substring(1, 5), 2);
          const sBoxValue = sBoxes[0][row][col]; // Using S1 for all (simplified)
          sBoxOutput += sBoxValue.toString(2).padStart(4, '0');
        }
        
        // Apply P-box permutation
        const pBoxOutput = permute(sBoxOutput, pBox);
        
        // XOR with left half
        const newRight = xor(left, pBoxOutput);
        
        // Store steps for visualization
        encryptionSteps.push({
          round: i + 1,
          left: left,
          right: right,
          roundKey: roundKeys[i],
          afterF: pBoxOutput
        });
        
        // Update left and right for next round
        left = right;
        right = newRight;
      }
      
      // Combine right and left (swap for the final step)
      const combined = right + left;
      
      // Apply final permutation
      const ciphertext = permute(combined, finalPermutation);
      
      return { ciphertext, encryptionSteps };
    }
    
    // DES Decryption
    function decrypt(ciphertext, roundKeys) {
      // Convert hex ciphertext to binary
      const binaryCiphertext = hexToBin(ciphertext);
      
      // Apply initial permutation
      const permutedCiphertext = permute(binaryCiphertext, initialPermutation);
      
      // Split into left and right halves
      let left = permutedCiphertext.substring(0, 32);
      let right = permutedCiphertext.substring(32);
      
      const decryptionSteps = [];
      
      // Use round keys in reverse order
      for (let i = 15; i >= 0; i--) {
        // Expand right half
        const expandedRight = permute(right, expansionTable);
        
        // XOR with round key
        const xorResult = xor(expandedRight, roundKeys[i]);
        
        // Apply S-boxes (simplified for visualization)
        let sBoxOutput = '';
        for (let j = 0; j < 8; j++) {
          const chunk = xorResult.substring(j * 6, (j + 1) * 6);
          const row = parseInt(chunk[0] + chunk[5], 2);
          const col = parseInt(chunk.substring(1, 5), 2);
          const sBoxValue = sBoxes[0][row][col]; // Using S1 for all (simplified)
          sBoxOutput += sBoxValue.toString(2).padStart(4, '0');
        }
        
        // Apply P-box permutation
        const pBoxOutput = permute(sBoxOutput, pBox);
        
        // XOR with left half
        const newRight = xor(left, pBoxOutput);
        
        // Store steps for visualization
        decryptionSteps.push({
          round: 16 - i,
          left: left,
          right: right,
          roundKey: roundKeys[i],
          afterF: pBoxOutput
        });
        
        // Update left and right for next round
        left = right;
        right = newRight;
      }
      
      // Combine right and left (swap for the final step)
      const combined = right + left;
      
      // Apply final permutation
      const plaintext = permute(combined, finalPermutation);
      
      return { plaintext, decryptionSteps };
    }
    
    // Visualization button
    const visualizeBtn = document.getElementById('visualize-btn');
    const visualizationSection = document.getElementById('visualization-section');
    const keyGenerationTable = document.getElementById('key-generation-table');
    const encryptionTable = document.getElementById('encryption-table');
    const decryptionTable = document.getElementById('decryption-table');
    const plaintextDisplay = document.getElementById('plaintext-display');
    const keyDisplay = document.getElementById('key-display');
    const encryptedDisplay = document.getElementById('encrypted-display');
    const decryptedDisplay = document.getElementById('decrypted-display');
    const inputText = document.getElementById('input-text');
    const keyValue = document.getElementById('key-value');
    
    if (visualizeBtn && visualizationSection) {
      visualizeBtn.addEventListener('click', function() {
        // Validate input
        const plaintext = inputText.value.trim().toUpperCase();
        const key = keyValue.value.trim().toUpperCase();
        
        if (!/^[0-9A-F]{16}$/.test(plaintext)) {
          alert('Please enter a valid 16-character hexadecimal plaintext.');
          return;
        }
        
        if (!/^[0-9A-F]{16}$/.test(key)) {
          alert('Please enter a valid 16-character hexadecimal key.');
          return;
        }
        
        // Show visualization section
        visualizationSection.classList.remove('d-none');
        
        // Generate keys
        const { roundKeys, keyGenerationSteps } = generateKeys(key);
        
        // Encrypt
        const { ciphertext, encryptionSteps } = encrypt(plaintext, roundKeys);
        
        // Decrypt
        const { plaintext: decryptedText, decryptionSteps } = decrypt(binToHex(ciphertext), roundKeys);
        
        // Display results
        plaintextDisplay.textContent = plaintext;
        keyDisplay.textContent = key;
        encryptedDisplay.textContent = binToHex(ciphertext);
        decryptedDisplay.textContent = binToHex(decryptedText);
        
        // Populate key generation table
        const keyGenTbody = keyGenerationTable.querySelector('tbody');
        keyGenTbody.innerHTML = '';
        
        keyGenerationSteps.forEach(step => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${step.round}</td>
            <td>${step.leftShift}</td>
            <td class="text-break"><small>${step.combinedKey.substring(0, 10)}...${step.combinedKey.substring(step.combinedKey.length - 10)}</small></td>
            <td class="text-break"><small>${step.roundKey.substring(0, 10)}...${step.roundKey.substring(step.roundKey.length - 10)}</small></td>
            <td>${step.roundKeyHex}</td>
          `;
          keyGenTbody.appendChild(row);
        });
        
        // Populate encryption table
        const encryptionTbody = encryptionTable.querySelector('tbody');
        encryptionTbody.innerHTML = '';
        
        encryptionSteps.forEach(step => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${step.round}</td>
            <td class="text-break"><small>${binToHex(step.left)}</small></td>
            <td class="text-break"><small>${binToHex(step.right)}</small></td>
            <td class="text-break"><small>${binToHex(step.roundKey)}</small></td>
            <td class="text-break"><small>${binToHex(step.afterF)}</small></td>
          `;
          encryptionTbody.appendChild(row);
        });
        
        // Populate decryption table
        const decryptionTbody = decryptionTable.querySelector('tbody');
        decryptionTbody.innerHTML = '';
        
        decryptionSteps.forEach(step => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${step.round}</td>
            <td class="text-break"><small>${binToHex(step.left)}</small></td>
            <td class="text-break"><small>${binToHex(step.right)}</small></td>
            <td class="text-break"><small>${binToHex(step.roundKey)}</small></td>
            <td class="text-break"><small>${binToHex(step.afterF)}</small></td>
          `;
          decryptionTbody.appendChild(row);
        });
      });
    }
    
    // Language selection and other code editor functionality
    // ... (rest of the existing code)
  });
</script>

<!-- Add dark theme styles -->
<style>
  body[data-bs-theme="dark"] {
    background-color: #1a1a1a;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .card {
    background-color: #2d2d2d;
    border-color: #404040;
  }
  
  body[data-bs-theme="dark"] .card-header:not(.bg-primary) {
    background-color: #404040;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .card-body {
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] pre.bg-light {
    background-color: #404040 !important;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .table {
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .table-striped tbody tr:nth-of-type(odd) {
    background-color: rgba(255, 255, 255, 0.05);
  }
  
  body[data-bs-theme="dark"] .bg-light {
    background-color: #404040 !important;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .text-muted {
    color: #a0a0a0 !important;
  }
  
  body[data-bs-theme="dark"] .form-control {
    background-color: #404040;
    border-color: #606060;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .form-control:focus {
    background-color: #404040;
    border-color: #007bff;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .form-select {
    background-color: #404040;
    border-color: #606060;
    color: #ffffff;
  }
  
  body[data-bs-theme="dark"] .code-output {
    background-color: #2d2d2d !important;
    border: 1px solid #404040;
  }
</style>

<%- include('../partials/footer') %> 